{
  "about": {
    "title": "About",
    "data": [
      {
        "title": "About Me!",
        "content": "Hi! I am a Software Developer who specializes in Backend Development, I am <br /> fluent in working with Go, Node, C++, Python and Also have know React <br /> and Svelte For UI Development."
      },
      {
        "title": "Introduction",
        "content": "lorem ipsum"
      },
      {
        "title": "Experience",
        "content": "<h4>Saas Implementation and API Integration - Courtyard Farms</h4> <br /> <div style='margin-left:2vw;'>lorem ipsum dolor sit amet</div>"
      }
    ]
  },
  "help": {
    "title": "Help",
    "data": [
      {
        "title": "cd",
        "content": "cd can be utilized to navigate the folder tree. <br /> <br /> <i style='margin-left:2vw;'>cd [relative folder path] </i> <br /> "
      },
      {
        "title": "ls",
        "content": "cd can be utilized to list all directories and files in the current working directory user is in. <br /><br /> <i style='margin-left:2vw;'>ls [no args] </i>"
      },
      {
        "title": "clear",
        "content": "clear can be utilized to delete all historical prompts being shown to the user. <br /><br /> <i style='margin-left:2vw;'>clear [no args] </i> <br /> "
      },
      {
        "title": "alias",
        "content": "alias can be utilized to view all aliases present in the shell instance. <br /><br /> <i style='margin-left:2vw;'>alias [no args] </i> <br /> "
      },
      {
        "title": "goto",
        "content": "goto can be utilized along side aliases to redirect the user to a different website. <br /><br /> <i style='margin-left:2vw;'>goto [alias {should be valid address}] </i> <br /> "
      },
      {
        "title": "help",
        "content": "help can be utilized to view all the commands and their syntax. <br /><br /> <i style='margin-left:2vw;'>help [no args] </i> <br /> "
      },
      {
        "title": "man",
        "content": "man can be utilized to view a man page with the details in the file you want to look at, must be present in the directory the file is in. <br /><br /> <i style='margin-left:2vw;'>man [file_name] </i> <br /> "
      }
    ]
  },
  "lapisoauth": {
    "title": "Lapis OAuth",
    "isOngoing": false,
    "deployed": false,
    "github": "https://github.com/NucleoFusion/NucleoOAuth",
    "deployment": "",
    "data": [
      {
        "title": "Introduction",
        "content": "An OAuth server following most of the RFC standards for OAuth responses, it is written in Golang with Redis as a server-side cache system and PostgreSQL as the persistent database."
      },
      {
        "title": "Experience",
        "content": "My main objective while planning and building this project was to learn more about how the authentication platforms that we use daily actually work and how they are implemented from a programmer's perspective. <br /> <br /> There was a lot I learned from this experience, the first and foremost being what authentication and authorization are and how, even though they are sometimes used synonymously, they are very different. Authentication is verifying a user's identity, whereas authorization is verifying what resources a specific user has access to, which is usually done using an access control system like RBAC, etc. <br /> <br /> I was also very intrigued by the different types of hashing/encoding techniques and how they differ from each other; for example, RSA uses a 2-key encoding algorithm with 1 public and 1 private key, AES uses a single-key encoding algorithm, and SHA256 uses a no-key hashing algorithm. This has really made my to-do list to learn more about the internal workings of these hashing algorithms. <br /> <br /> Also a somewhat new experience was the need and the speed of a cache system; at the start, when I realized that a cache system would be required, I thought and tried to implement my own, but I soon realized that creating a cache system is a big task, and although I will be able to have a working system, it would be more error-prone, more complex, and more unsafe than using a cache database or an in-memory database such as Redis. <br /> <br /> Overall, this was one of my most successful projects as I look forward to the amount of knowledge I can gain from a project and how it can help me become better in my field."
      },
      {
        "title": "Stack",
        "content": "<div> <h3>Golang</h3> <h3> React </h3> <h3> PostgreSQL </h3> <h3> Redis <h3 /> </div>"
      }
    ]
  },
  "lapisblog": {
    "title": "LapisBlog",
    "isOngoing": true,
    "deployed": false,
    "github": "https://github.com/NucleoFusion/LapisBlog",
    "deployment": "",
    "data": [
      {
        "title": "Introduction",
        "content": "A social network platform allowing anonymous or identifiable interactions with posts. Built with Go and Postgres for backend, frontend undecided (possibly Svelte), focusing on privacy and user control over interactions."
      },
      {
        "title": "Experience",
        "content": "Although this project is in development, I always start a project with some ultimate learning opportunity and/or goal in mind. And for this, my focus was entirely on concurrency and API authentication systems.<br /><br /> My main focus with this project was to learn in depth about Go’s concurrency model, which includes goroutines, channels, and more. The most difficult part of this project till now is no doubt keeping track of the different goroutines and the channels that communicate between them. Since I wanted to practice using goroutines, I went overboard with using goroutines, so much so that almost all my API routes have at least 2 goroutines, even for functions that do not need to be performed asynchronously, such as matching the password of a user, because if any error occurs or the password doesn't match, you have to terminate the process anyway.<br /><br /> This, along with cluttering my code, also made me realize the importance of code commenting and documentation; if any modification had to be made, it was a tough 5-10 min to understand what I had done previously. To help me with this, I started using Figma or a similar whiteboard/notes application to create a flowchart of routes that I have made. For this project you can view them <a href='https://www.figma.com/board/oVWcohrQhGvlxgZeHSJt4e/lapisblog-routes?node-id=0-1&t=VDfSmWE7Jy3PfSUP-1'>here</a>. <br /><br /> Since I created my own JWT and API key authentication systems, I was able to learn a lot about the internal workings of these systems, such as the format of a JWT and how it should be parsed and handled on the server side. <br /><br /> I am certain that while building this project I will learn a lot more than I have mentioned here. I will make sure to keep this article up-to-date with my learning."
      },
      {
        "title": "Stack",
        "content": "<div> <h3>Golang</h3> <h3> PostgreSQL </h3> </div>"
      }
    ]
  },
  "transpohub": {
    "title": "Transpohub",
    "deployed": true,
    "isOngoing": false,
    "github": "https://github.com/NucleoFusion/Mobility-Future",
    "deployment": "https://transpohub.vercel.app",
    "data": [
      {
        "title": "Introduction",
        "content": "A freelance platform for transporters to connect with clients for jobs, created as a group project using React, Node.js, and MongoDB. It aims to improve transportation facilities in the user's country."
      },
      {
        "title": "Experience",
        "content": "Transpohub was a project my friends and I started when we realized the lack of digitalization in the transport industry. While every field was moving forward with new technologies and software, the transport industry seemed stagnant, highly reliant on verbal communication to provide jobs to the transporters.  <br /><br /> That is when we thought of a platform where we could connect transporters with potential clients while also providing transporters with a better work environment since an increase in jobs will also create a choice, a choice where the transporter can choose which job he would like to take.  <br /><br /> This project was a deviation from how I undergo my own projects because before suggesting a change or adding a feature, I had to consult my friends on whether that change would be good/bad or just cumbersome. It was also different because there were times when I had to rely on other people’s work before I could code my own. <br /><br /> Although there were downsides to this approach, them being a more time-consuming, highly 3rd person-reliant atmosphere, etc. The advantages far outweighed the disadvantages; I don't think I could have provided such a good project if I did not have the help and insight of my friends."
      },
      {
        "title": "Stack",
        "content": "<div> <h3>Node</h3> <h3> React </h3> <h3> MongoDB </h3> </div>"
      }
    ]
  },
  "lapischat": {
    "title": "Lapis Chat",
    "isOngoing": true,
    "deployed": false,
    "github": "https://github.com/NucleoFusion/LapisChat",
    "deployment": "",
    "data": [
      {
        "title": "Introduction",
        "content": "A Short-lived Chat application created using Tauri(Rust and Svelte) and Golang, where a collection of users can create a short-lived chat session whose data is only valid till the session is live and destroyed prior to that. "
      },
      {
        "title": "Experience",
        "content": "This project is one of my newer ones. To explain the premise of this project, since it is pretty hard to explain through words, it is that this project allows a group of people to message each other, but their messages are only stored while their session is active, and after a session has been ended, all the relevant data is deleted. <br /><br /> Now, moving to what I aim to learn through this project. My main goal with this project is to get a decent grasp on Rust and its usage in an application. Rust was a language that was very interesting to me; it showcased an innovative approach to different solutions. For example, the way Rust handles memory management without the use of a garbage collector and instead uses lifetimes and scopes to decide when a pointer should be freed. This also goes hand in hand with its memory safety features, which include the borrow and ownership concept. <br /><br /> All this may sound very innovative, but my two favorite features of Rust are somewhat lackluster when compared to the above. They are enumerations and the match cases to go with that and the strict error systems. I like the enumerations purely because working with Go for a long time and spending hours trying to make some enum-like system work was bothering me a lot, and having an enum system built into a language makes it really good. What I like about the error system in Rust is that it forces me to make readable and scalable code. If I have completed an application in Rust, I can be sure that the code is at worst average. <br /><br /> I also wanted to explore Tauri, a Rust crate that allows you to build cross-platform applications using almost any frontend UI framework, such as React or Svelte. I wanted to use this crate to expand my repertoire to different device types and also use Rust along with it. <br /><br /> One more important topic I wanted to learn through this project was WebSockets. Although I have learned about WebSockets theoretically, I have never actually created an application that actively required WebSockets. I chose to go with Go as the websocket server since I am more familiar with building server-side applications using Go, and to jump straight into Rust with Websockets would be a lot harder."
      },
      {
        "title": "Stack",
        "content": "<div> <h3>Rust</h3> <h3> Svelte </h3> <h3> Golang </h3> </div>"
      }
    ]
  }
}
